#+TITLE: WIP: Nothing /Really/ Matters
#+SUBTITLE: The option type as an icon of absence

* A joke about nothing

There is an old philosophy joke, which I learned in this form:

#+begin_quote
Sartre is at a cafe. The server comes up to take his order. Sartre orders a
coffee without cream.

The server goes to fetch the coffee, but quickly returns.

"I'm sorry mister Sartre. We are all out of cream. Would you like coffee without
milk instead?"
#+end_quote

- https://quoteinvestigator.com/2024/06/01/coffee-cream/
- https://www.thephilosophicalsalon.com/you-are-not-having-milk/
- https://www.youtube.com/watch?v=jU6nB-uJh68

* Explaining the joke

The joke plays on the tension between extensional and intentional semantics.

The joke's [[https://www.merriam-webster.com/dictionary/gimmick][gimmick]] is the idea that non-presence is determined by that
which is not present[fn:1]: since milk is distinct from cream, the non-presence
of milk is distinct from the non-presence of cream; therefore, ordering coffee
without milk is distinct from ordering coffee without cream.

Viewed [[https://en.wikipedia.org/wiki/Extensional_and_intensional_definitions][extensionally]], concerned only with the denotation, this is a "[[https://en.wikipedia.org/wiki/Distinction_without_a_difference][distinction
without a difference]]": assuming the absence of implicit additives (e.g., sugar),
the set of all cups of coffee without cream is identical to the set of all cups
of coffee without milk; i.e., the set of all cups of black coffee. So if you
just want a black coffee, it makes no difference which dairy product is omitted.
But the key [[https://en.wiktionary.org/wiki/gimmick#Noun][gimmick]] at work in the joke is this, viewed intensionally, concerned
with the sense, the distinction does make a difference, it's not a distinction
that makes any difference to our common sense. The frivolousness of /this/
additive omission is tied to the similarity of the dairy. But not all
distinctions in non-presence are equally indistinguishable.

# TODO cut?
Consider the same cup of coffee offered without cream versus offered without
bleach. The difference in intention is disturbing. I'd refuse the latter: the
offer to omit bleach implies the possibility of its presence so it lands like
a threat. This shows that /non-presence/ is determined by /that which is not
present/ even when what is present is left unchanged by the absence. Tho this
determination only makes a difference in terms of sense and intention, a
difference /is/ made.

Often, varieties of non-presence entail a real and objective difference in what
is present: the distinction between having no sight and having no hearing marks
a meaningful difference; we each know (or will come to know) the deadly serious
difference made by the distinct kinds of nothingness met in the absence of each
missing loved one.

What is not present determines differences in non-presence in at least two ways:
the potential presence of what is non-present marks differences in [[https://en.wikipedia.org/wiki/Intension][intention]];
what remains present can be distinctly different due to the absence of what is
missing. As a result, everything absent is non-present in its own way.  And yet
we know there is also a shared structure common to all the different forms of
absence, which is why it makes sense to consider the general concept of
non-presence, as we've been doing.

* TODO The option type as an icon of absence

We can interpret [[https://en.wikipedia.org/wiki/Option_type][the =option= type]] as an [[https://en.wikipedia.org/wiki/Iconicity][icon]] of the phenomena of absence. To
aid in the exposition of this interpretation, we'll build up a small domain of
discourse.

We assume we have in our domain of discourse the type =int= of integers, and add
the following types of liquid

#+begin_src ocaml :session
type milk = [ `Milk ]

type cream = [ `Cream ]

type coffee = [ `Coffee ]
#+end_src

#+RESULTS:
: type milk = [ `Milk ]
: type cream = [ `Cream ]
: type coffee = [ `Coffee ]

# TODO REMOVE?

Let's specify a way of describing substances. A substance will have some form,
which we consider to express the type of the substance, and some way of deriving
material constitutive of that substance.

#+NAME: representation of substance
#+begin_src ocaml :session
module type Substance = sig
  type t
  (** The form of the substance is it's principle type. Depending on your
      ontology, you might say that the form is given by the substance's
      chemical composition, its platonic idea, or whatever. *)

  val v : t
  (** A material instances of the substance, e.g., chemical compounds, monads,
      or divine eminations. *)
end
#+end_src

#+RESULTS: representation of substance
: * *       *   module type Substance = sig type t val v : t end


The [[representation of substance]] let's us distinguish between kinds of things and
instances of that kind.

Let's define a way of constructing measures of different kinds of liquid:

#+begin_src ocaml :session
module Liquid (S : Substance) : sig
  type milliliters = int
  (** The units by which all our liquids are measured *)

  type t
  (** The type of an amount of liquid *)

  val v : int -> t
  (** [v ml] is [ml] milliliters of liquid *)

  val amount : t -> milliliters
  (** [amount l] is the amount of milliliters of the liquid [l] *)
end = struct
  type milliliters = int

  type t = S.t * milliliters

  let v ml = (S.v, ml)

  let amount (_, ml) = ml
end
#+end_src

#+RESULTS:
: module Liquid :
:   (S : Substance) ->
:     sig
:       type milliliters = int
:       type t
:       val v : int -> t
:       val amount : t -> milliliters
:     end

Let there be some liquids:

#+begin_src ocaml :session
module Coffee = Liquid (struct
  type t = Coffee

  let v = Coffee
end)

module Milk = Liquid (struct
  type t = Milk

  let v = Milk
end)

module Cream = Liquid (struct
  type t = Cream

  let v = Cream
end)
#+end_src

#+RESULTS:
#+begin_example
module Coffee :
  sig
    type milliliters = int
    type t
    val v : int -> t
    val amount : t -> milliliters
  end
module Milk :
  sig
    type milliliters = int
    type t
    val v : int -> t
    val amount : t -> milliliters
  end
module Cream :
  sig
    type milliliters = int
    type t
    val v : int -> t
    val amount : t -> milliliters
  end
#+end_example

Now we need a way of representing the absence of a liquid

#+NAME: declaration of the option type constructor
#+begin_src ocaml :session
module Option = struct
  type 'a t =
    | Some of 'a
    | None
end
#+end_src

#+RESULTS: declaration of the option type constructor
: Some of 'a | None end

#+RESULTS:
: type 'a option = Some of 'a | None

Read the above [[declaration of the option type constructor]] as follows:

- We declare a type constructor =Option.t= which is polymorphic over a type
  ='a=.
  E.g.,
  - =int Option.t= :: the type of optional integers
  - =milk Option.t= :: the type of optional milk
  - =cream Option.t= :: the type of optional cream
- For any optional type we construct, we provide two ways to constructor values
  of this type:
  - =Some of 'a= :: representing the presence of a value of type ='a=. E.g.
    - =Some 1= :: a value of type =int option=
    - =Some Milk.v= :: a value of type =Milk.t option=
  - =None= :: representing the absence of a value of any type ='a=. E.g.,
    - =None : Milk.t option= :: the absence of milk
    - =None : Cream.t option= :: the absence of cream

** TODO Absence of an additive
Coffee without milk is the same as coffee without cream.
** TODO Absence of a component
I would be different without my arms than I would be without my legs.
** TODO Irreversable vs. reversable additives
You can pick the pepperonis off a pizza, but cannot take the cream out of
coffee.

*** Conjunction vs. mixture
Hart on stuff
*** This shows us why we should model the order differently than the product

** Types of things
Things are of a different type when we can't gather them together.
=[a ; b; c] : 't list=. We can only form this list if =a : 't= and =b : 't= and
=c : 't=. So we can form =[1;2;3]= since =1 : int=, =2 : int=, and =3 : int=,
but we cannot form =[1; "2"]= since =1 : int= and ="2" : string=.

#+begin_src ocaml
type drink = Coffee | Tea
type additive = Milk | Cream | Honey

type order = {drink = drink; additive = additive}
type 'additive coffe = Coffe of 'additive option
type additive = Cream | Milk
#+end_src

#+RESULTS:
: type 'additive coffe = Coffe of 'additive option
: type additive = Cream | Milk

** How do we specify Sartre's order?




* Footnotes

[fn:1] See TODO for a more detail on the philosophical underpinnings of the
joke.
